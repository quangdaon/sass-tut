<!DOCTYPE html>
<html>
	<head>
		<title>Sass Lunch & Learn</title>
		<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro|Satisfy" rel="stylesheet">
		<link rel="stylesheet" href="./css/base.css">
		<link rel="stylesheet" href="./css/training.css">
	</head>
	<body>
		<header class="header">
			<h1>Styling with</h1><img src="./img/sass-logo.svg">
		</header>
		<div id="main">
			<section id="history">
				<h2>History</h2>
				<div id="sass">
					<h3>Sass</h3>
					<p>Sass (Syntactically Awesome StyleSheets) started out as a whitespace-dependent scripting language that compiles into CSS. In other words, it is a "CSS preprocessor". It was first released as a companion to Haml (HTML Abstraction Markup Language), a templating language for HTML that follows a similar indent-based syntax. As a preprocessor, Sass' primary purpose is to extend the CSS language with mechanisms found in other programming languages. Files written in the indent syntax typically end in ".sass".</p>
					<div class="example">
						<h4>Example</h4>
						<div>
							<pre><code>body
	color: red
	h3
		font-size: 122em</code></pre>
						</div>
					</div>
				</div>
				<div id="scss">
					<h3>SCSS</h3>
					<p>As of the third iteration of the Sass preprocessor (Sass 3), the language has broken away from its Haml roots and adapted a new syntax similar to CSS. This new default syntax is renamed SCSS (Sassy CSS). Unlike Sass, which can be considered its own language, SCSS is known as a "metalanguage," meaning it is strictly an extension of CSS. Any valid CSS is also valid SCSS. For the rest of this document, Sass will refer to the new SCSS syntax. Files written in this new syntax are succeeded by the ".scss" extension.</p>
					<div class="example">
						<h4>Example</h4>
						<div>
							<pre><code>body {
	color: red;
	h3 {
		font-size: 122em;
	}
}</code></pre>
						</div>
					</div>
				</div>
			</section>
			<section id="nesting">
				<h2>Nesting</h2>
				<p>As you may have already noticed above, Sass supports the nesting of selectors. This is one of the biggest features of Sass. Selectors nested inside another selector are treated as a child of the former. More specifically, the child is appended to the end of the parent selector after a space. There is no limit to how deep selectors can be nested, though ten levels deep is generally accepted as overkill.</p>
				<div class="example">
					<h4>Example</h4>
					<div class="columns">
						<div>
							<h5>Before</h5>
							<pre><code>body {
	font-size: 3px;
	h3 {
		color: red;
	}
}</code></pre>
						</div>
						<div>
							<h5>After</h5>
							<pre><code>body {
	font-size: 3px;
}

body h3 {
	color: red;
}</code></pre>
						</div>
					</div>
				</div>
				<div id="the---operator">
					<h3>The &amp; Operator</h3>
					<p>With nesting, Sass introduces a new operator: the ampersand (&). It is a common misconception that the ampersand is used to "extend" the previous selector. To an extent, this is true. For example, nesting "h3" with "&:hover" does generate "h3:hover". This can be useful for psuedo selectors, such as ":hover", or for adding another class to a selector, ".like.this". However, it actually does a bit more. the & operator actually calculates the entire parent selector, then places it verbatim wherever it is used.</p>
					<p class="pagebreak"></p>
					<div class="example">
						<h4>Example</h4>
						<div class="columns">
							<div>
								<h5>Before</h5>
								<pre><code>a.link {
	&:hover {
		color: #f00;
	}
	&:active {
		color: #faa;
	}
	& > &:hover + & {
		&:before, &:after {
			content: 'Why???';
		}
	}
}</code></pre>
							</div>
							<div>
								<h5>After</h5>
								<pre><code>a.link:hover {
	color: #f00;
}

a.link:active {
	color: #faa;
}

a.link > a.link:hover + a.link:before,
a.link > a.link:hover + a.link:after {
	content: 'Why???';
}</code></pre>
							</div>
						</div>
					</div>
					<div class="example source">
						<h4>Source Code for Example Boxes</h4>
						<div>
							<pre><code>.example {
	display: block;
	text-align: center;
	> div {
		display: inline-block;
		background: #eee;
		padding: 0 20px;
		&:hover {
			background: #ddd;
		}
	}
	.columns {
		display: inline-block;
		h5 {
			margin: 0;
		}
		div {
			display: inline-block;
			margin: 10px;
			vertical-align: top;
		}
	}
	pre {
		text-align: left;
	}
}</code></pre>
						</div>
					</div>
				</div>
			</section>
			<p class="pagebreak"></p>
			<section id="variables">
				<h2>Variables</h2>
				<p>One of the features that make SCSS closer to a standard programming language than it is to CSS is the use of variables. Like other languages, variables define a certain value, that is then "injected" to any point in the code when it is called. However, rather than storing a value to be manipulated later, variables are mostly used to keep track of commonly used colors, fonts, etc. to make "theming" a website much easier. Variables in Sass are preceded by a dollar sign ($) and can contain alphanumeric values of dashes.</p>
				<div class="example">
					<h4>Example</h4>
					<div class="columns">
						<div>
							<h5>Before</h5>
							<pre><code>$color: red;

h1 {
	color: $color;
	border: 1px solid $color;
}</code></pre>
						</div>
						<div>
							<h5>After</h5>
							<pre><code>h1 {
	color: red;
	border: 1px solid red;
}</code></pre>
						</div>
					</div>
				</div>
				<p class="pagebreak"></p>
				<div id="interpolation">
					<h3>Interpolation</h3>
					<p>By default, Sass variables be only be used as values to CSS properties. But when needed, they can also be interpolated as strings. This is especially useful if you want to store a certain selector. For example, modern Graydient websites use variables to store our media queries for different screen sizes. NOTE: Please don't ask Quangdao to explain this section. He doesn't fully understand it either<sup>[<a href="http://www.sass-lang.com/documentation/file.SASS_REFERENCE.html#interpolation_" target="_blank">1</a>]</sup>.
					</p>
					<div class="example">
						<h4>Example</h4>
						<div class="columns">
							<div>
								<h5>Before</h5>
								<pre><code>$smallScreen: 'only screen and (max-width: 767px)';

@media #{$smallScreen} {
	h3 {
		color: tomato;
	}
}</code></pre>
							</div>
							<div>
								<h5>After</h5>
								<pre><code>@media only screen and (max-width: 767px) {
	h3 {
		color: tomato;
	}
}</code></pre>
							</div>
						</div>
					</div>
					<div class="example source">
						<h4>Source Variables</h4>
						<div>
							<pre><code>// Fonts
$font-1: "Source Sans Pro", "Helvetica Neue", Helvetica, Arial, sans-serif;
$font-2: "Satisfy", cursive;

// Colors
$color-1: #c6538c;

// Media Queries
$smallScreen: 'only screen and (max-width: 767px)';</code></pre>
						</div>
					</div>
				</div>
			</section>
			<p class="pagebreak"></p>
			<section id="mixins">
				<h2>Mixins</h2>
				<p>Another useful feature of Sass is mixins. Essentially, a mixin is a block of reusable code that can be used to automatically generate some CSS properties. In a way, mixins are reminiscent of a function in other programming languages. Mixins are defined using the "@mixin" keyword and otherwise works just like a normal CSS selector. They can be called using "@include mixin-name".</p>
				<div class="example">
					<h4>Example 1</h4>
					<div class="columns">
						<div>
							<h5>Before</h5>
							<pre><code>@mixin humongous {
	font-size: 1000px;
	width: 1000px;
	height: 1000px;
}

div {
	@include humongous;
}</code></pre>
						</div>
						<div>
							<h5>After</h5>
							<pre><code>div {
	font-size: 1000px;
	width: 1000px;
	height: 1000px;
}</code></pre>
						</div>
					</div>
				</div>
				<div class="example">
					<h4>Example 2 - The following buttons are created using mixins.</h4><a class="button-1" href="#">Test Button</a><a class="button-2" href="#">Test Button</a><a class="button-3" href="#">Test Button</a>
				</div>
				<div class="example source">
					<h4>Source Code</h4>
					<div>
						<pre><code>@mixin button($col) {
	background: $col;
	color: setTextColor($col);
	font-weight: bold;
	margin: 0 10px;
	text-decoration: none;
	padding: 10px 20px;
	border-radius: 10px;
	&:hover {
		background: darken($col, 5%);
	}
}</code></pre>
					</div>
				</div>
			</section>
			<p class="pagebreak"></p>
			<section id="functions-and-directives">
				<h2>Functions and Directives</h2>
				<p>This is where Sass really defines itself as a programming language. Earlier, it was stated that mixins are like functions. However, Sass already has built-in support for actual functions. Mixins and functions serve similar purposes, being to reduce the repetition in your code; however, mixins are primarily used to generate blocks of code, while functions mainly calculate values. In a way, mixins are closer to "document.write()" in JavaScript, while functions are... well, functions.</p>
				<div class="example">
					<h4>Example from Official Docs</h4>
					<div class="columns">
						<div>
							<h5>Before</h5>
							<pre><code>@function returnOneIfOneAndEighteenIfNot($in) {
	@if($in = 1) {
		@return 1;
	} @else {
		@return 'eighteen';
	}
}

p:before {
	content: returnOneIfOneAndEighteenIfNot(42);
}</code></pre>
						</div>
						<div>
							<h5>After</h5>
							<pre><code>p:before {
	content: 'eighteen';
}</code></pre>
						</div>
					</div>
				</div>
				<div class="example">
					<h4>Example 2 - See Buttons Above. The text of the colors are determined by a function that checks the brightness of the background.</h4>
				</div>
				<div class="example source">
					<div>
						<pre><code>@function setTextColor($color) {
	@if (lightness($color) >= 50) {
		@return #000000;
	} @else {
		@return #ffffff;
	}
}</code></pre>
					</div>
				</div>
				<div id="control-directives">
					<h3>Control Directives</h3>
					<p>Control directives are simply a fancy name for loops and conditionals. In Sass, one can use "@if" statements to alter a certain value. These directives function similarly to how they would in most programming languages. Due to the extensiveness of these directives, check the references for a link to the official documents instead<sup>[<a href="http://www.sass-lang.com/documentation/file.SASS_REFERENCE.html#control_directives__expressions" target="_blank">2</a>]</sup>.
					</p>
					<div class="example">
						<h4>Example from Official Docs</h4>
						<div class="columns">
							<div>
								<h5>Before</h5>
								<pre><code>@for $i from 1 through 3 {
	.item-#{$i} { width: 2em * $i; }
}</code></pre>
							</div>
							<div>
								<h5>After</h5>
								<pre><code>.item-1 {
	width: 2em;
}

.item-2 {
	width: 4em;
}

.item-3 {
	width: 6em;
}</code></pre>
							</div>
						</div>
					</div>
				</div>
				<div id="built-in-functions">
					<h3>Built-In Functions</h3>
					<p>Sass has a variety of pre-made functions. The most helpful ones, in particular, are the color manipulating functions. For example, the function "darken(#f00, 10%)" calculates a new color that is 10% darker than red. A list of the built-in functions can be found in the references<sup>[<a href="http://www.sass-lang.com/documentation/Sass/Script/Functions.html" target="_blank">3</a>]</sup>.
					</p>
				</div>
			</section>
			<p class="pagebreak"></p>
			<section id="imports">
				<h2>Imports</h2>
				<p>Like regular CSS, Sass supports importing other files using the "@import" directive. Unlike CSS, however, upon compilation, the contents of the referenced files are actually pull into the compiled result. In short, the Sass compiler first replaces import statements with the actual content, and <i>then</i> compiles it as a single file. This allows developers to use variables and mixins that are declared in another file, as long as the file containing the variable is imported before the file referencing it.</p>
				<p>For organization purposes, many developers and teams follow patterns, such the 7-1 Pattern![+notes(4)], where a there's a single core file that imports all other files. SCSS files that are meant to only be used as partials should start with an underscore (_). This prevents the compiling from compiling it as a separate file.</p>
				<p>Plugin developers for Sass often add the "!default" flag to their configurable variables. This flag stops the variable from being assigned if it already exists. The benefit of doing this is so users of the plugin won't have to manipulate the vendor file itself, keeping it clean in case updates are needed.</p>
				<div class="example">
					<h4>Example</h4>
					<div class="columns">
						<div>
							<h5>File: main.scss</h5>
							<pre><code>$plugin-color: tomato;
$nondefault: red;

p {
	background: $plugin-color;
	color: $nondefault;
}

@import 'vendor/plugin';</code></pre>
						</div>
						<div>
							<h5>File: vendor/_plugin.scss</h5>
							<pre><code>$plugin-color: orange !default;
$nondefault: purple;

* {
	background: $plugin-color;
	color: $nondefault;
}</code></pre>
						</div>
					</div>
				</div>
				<div class="example">
					<h4>Results</h4>
					<div>
						<pre><code>p {
	background: tomato;
	color: red;
}

* {
	background: tomato;
	color: purple;
}</code></pre>
					</div>
				</div>
			</section>
			<section id="let-s-get-crazy">
				<h2>Let's Get Crazy!</h2>
				<p>So far, we've seen nesting, mixins, variables, and functions. The examples so far mostly demonstrate conveniences, rather than actual benefits. Combining these techniques allows us to generate much more complex styles that would be nearly impossible to replicate using CSS alone. For example, using just SCSS (and 100 divs in HTML), the heart shape below can be created in just 26 lines of code, whereas the same effect can take up to hundreds of lines of CSS to replicate.</p>
				<div class="insanity">
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
					<div></div>
				</div>
				<div class="example source">
					<h4>Source Code</h4>
					<p>In the Lunch & Learn, we went through how to style 100 divs without needing a hundred separate selectors (although that many is generated into the CSS).</p>
					<div>
						<pre><code>.insanity {
	width: 100px;
	height: 100px;
	margin: 60px auto 0;
	position: relative;
	div {
		border-radius: 100%;
		position: absolute;
		width: 100%;
		height: 100%;
		transform-origin: bottom;
		$sharpness: 100;
		@for $i from 1 through $sharpness {
			&:nth-child() {
				$mod: (($i % 2) * 2) - 1;
				$h: 255 * ($i / $sharpness);
				$w: ($sharpness - $i) / $sharpness;
				background: hsl($h, 100, 50);
				transform: scale($w, $w) translateY(-50%) translateX(NaN%);
			}
		}
	}
}</code></pre>
					</div>
				</div>
			</section>
			<p class="pagebreak"></p>
			<section id="reminders">
				<h2>Reminders</h2>
				<ul>
					<li>Unlike regular CSS, SCSS requires terminating your properties with semicolons.</li>
					<li>SCSS is only aware of the CSS <i>syntax</i>, and not the language itself. This means that invalid properties, such as "font-size: green;" will be accepted by the compiler.</li>
				</ul>
			</section>
			<section id="references">
				<h2>References</h2>
				<ol>
					<li><a href="http://www.sass-lang.com/documentation/file.SASS_REFERENCE.html#interpolation_">http://www.sass-lang.com/documentation/file.SASS_REFERENCE.html#interpolation_</a></li>
					<li><a href="http://www.sass-lang.com/documentation/file.SASS_REFERENCE.html#control_directives__expressions">http://www.sass-lang.com/documentation/file.SASS_REFERENCE.html#control_directives__expressions</a></li>
					<li><a href="http://www.sass-lang.com/documentation/Sass/Script/Functions.html">http://www.sass-lang.com/documentation/Sass/Script/Functions.html</a></li>
					<li><a href="https://sass-guidelin.es/#the-7-1-pattern">https://sass-guidelin.es/#the-7-1-pattern</a></li>
				</ol>
			</section>
			<section id="resources">
				<h2>Resources</h2>
				<ul>
					<li><a href="https://www.sassmeister.com/">https://www.sassmeister.com/</a> - Great place to practice.</li>
					<li><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html">http://sass-lang.com/documentation/file.SASS_REFERENCE.html</a> - Official Documentations</li>
					<li><a href="https://emmet.io/">https://emmet.io/</a> - Emmet - An awesome tool for CSS.</li>
				</ul>
			</section>
			<script src="./js/highlight.pack.js"></script>
			<script>hljs.initHighlightingOnLoad();</script>
		</div>
	</body>
</html>